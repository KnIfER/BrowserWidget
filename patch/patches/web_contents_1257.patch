diff --git chrome/browser/extensions/api/tab_capture/offscreen_tab.cc chrome/browser/extensions/api/tab_capture/offscreen_tab.cc
index 776dd0a..1a86478 100644
--- chrome/browser/extensions/api/tab_capture/offscreen_tab.cc
+++ chrome/browser/extensions/api/tab_capture/offscreen_tab.cc
@@ -225,7 +225,9 @@ bool OffscreenTab::ShouldCreateWebContents(
     const std::string& frame_name,
     const GURL& target_url,
     const std::string& partition_id,
-    content::SessionStorageNamespace* session_storage_namespace) {
+    content::SessionStorageNamespace* session_storage_namespace,
+    content::WebContentsView** view,
+    content::RenderViewHostDelegateView** delegate_view) {
   DCHECK_EQ(offscreen_tab_web_contents_.get(), web_contents);
   // Disallow creating separate WebContentses.  The WebContents implementation
   // uses this to spawn new windows/tabs, which is also not allowed for
diff --git chrome/browser/extensions/api/tab_capture/offscreen_tab.h chrome/browser/extensions/api/tab_capture/offscreen_tab.h
index 992160d..b5dcc72 100644
--- chrome/browser/extensions/api/tab_capture/offscreen_tab.h
+++ chrome/browser/extensions/api/tab_capture/offscreen_tab.h
@@ -150,7 +150,9 @@ class OffscreenTab : protected content::WebContentsDelegate,
       const std::string& frame_name,
       const GURL& target_url,
       const std::string& partition_id,
-      content::SessionStorageNamespace* session_storage_namespace) final;
+      content::SessionStorageNamespace* session_storage_namespace,
+      content::WebContentsView** view,
+      content::RenderViewHostDelegateView** delegate_view) final;
   bool EmbedsFullscreenWidget() const final;
   void EnterFullscreenModeForTab(content::WebContents* contents,
                                  const GURL& origin) final;
diff --git chrome/browser/prerender/prerender_contents.cc chrome/browser/prerender/prerender_contents.cc
index aea147d..cac0c15 100644
--- chrome/browser/prerender/prerender_contents.cc
+++ chrome/browser/prerender/prerender_contents.cc
@@ -142,7 +142,9 @@ class PrerenderContents::WebContentsDelegateImpl
       const std::string& frame_name,
       const GURL& target_url,
       const std::string& partition_id,
-      SessionStorageNamespace* session_storage_namespace) override {
+      SessionStorageNamespace* session_storage_namespace,
+      content::WebContentsView** view,
+      content::RenderViewHostDelegateView** delegate_view) override {
     // Since we don't want to permit child windows that would have a
     // window.opener property, terminate prerendering.
     prerender_contents_->Destroy(FINAL_STATUS_CREATE_NEW_WINDOW);
diff --git chrome/browser/ui/browser.cc chrome/browser/ui/browser.cc
index ffcba10..514c431 100644
--- chrome/browser/ui/browser.cc
+++ chrome/browser/ui/browser.cc
@@ -1600,7 +1600,9 @@ bool Browser::ShouldCreateWebContents(
     const std::string& frame_name,
     const GURL& target_url,
     const std::string& partition_id,
-    content::SessionStorageNamespace* session_storage_namespace) {
+    content::SessionStorageNamespace* session_storage_namespace,
+    content::WebContentsView** view,
+    content::RenderViewHostDelegateView** delegate_view) {
   if (window_container_type == WINDOW_CONTAINER_TYPE_BACKGROUND) {
     // If a BackgroundContents is created, suppress the normal WebContents.
     return !MaybeCreateBackgroundContents(
diff --git chrome/browser/ui/browser.h chrome/browser/ui/browser.h
index 0860714..a011ad7 100644
--- chrome/browser/ui/browser.h
+++ chrome/browser/ui/browser.h
@@ -626,7 +626,9 @@ class Browser : public TabStripModelObserver,
       const std::string& frame_name,
       const GURL& target_url,
       const std::string& partition_id,
-      content::SessionStorageNamespace* session_storage_namespace) override;
+      content::SessionStorageNamespace* session_storage_namespace,
+      content::WebContentsView** view,
+      content::RenderViewHostDelegateView** delegate_view) override;
   void WebContentsCreated(content::WebContents* source_contents,
                           int opener_render_process_id,
                           int opener_render_frame_id,
diff --git components/offline_pages/content/background_loader/background_loader_contents.cc components/offline_pages/content/background_loader/background_loader_contents.cc
index 5998fc7..a98eea6 100644
--- components/offline_pages/content/background_loader/background_loader_contents.cc
+++ components/offline_pages/content/background_loader/background_loader_contents.cc
@@ -71,7 +71,9 @@ bool BackgroundLoaderContents::ShouldCreateWebContents(
     const std::string& frame_name,
     const GURL& target_url,
     const std::string& partition_id,
-    content::SessionStorageNamespace* session_storage_namespace) {
+    content::SessionStorageNamespace* session_storage_namespace,
+    content::WebContentsView** view,
+    content::RenderViewHostDelegateView** delegate_view) {
   // Background pages should not create other webcontents/tabs.
   return false;
 }
diff --git components/offline_pages/content/background_loader/background_loader_contents.h components/offline_pages/content/background_loader/background_loader_contents.h
index 43b6cea..29b6ae2 100644
--- components/offline_pages/content/background_loader/background_loader_contents.h
+++ components/offline_pages/content/background_loader/background_loader_contents.h
@@ -54,7 +54,9 @@ class BackgroundLoaderContents : public content::WebContentsDelegate {
       const std::string& frame_name,
       const GURL& target_url,
       const std::string& partition_id,
-      content::SessionStorageNamespace* session_storage_namespace) override;
+      content::SessionStorageNamespace* session_storage_namespace,
+      content::WebContentsView** view,
+      content::RenderViewHostDelegateView** delegate_view) override;
 
   void AddNewContents(content::WebContents* source,
                       content::WebContents* new_contents,
diff --git content/browser/web_contents/web_contents_impl.cc content/browser/web_contents/web_contents_impl.cc
index 35b6f47..d444e66 100644
--- content/browser/web_contents/web_contents_impl.cc
+++ content/browser/web_contents/web_contents_impl.cc
@@ -1560,6 +1560,12 @@ void WebContentsImpl::Init(const WebContents::CreateParams& params) {
   std::string unique_name;
   frame_tree_.root()->SetFrameName(params.main_frame_name, unique_name);
 
+  if (params.view && params.delegate_view) {
+    view_.reset(params.view);
+    render_view_host_delegate_view_ = params.delegate_view;
+  }
+
+  if (!view_) {
   WebContentsViewDelegate* delegate =
       GetContentClient()->browser()->GetWebContentsViewDelegate(this);
 
@@ -1576,6 +1582,7 @@ void WebContentsImpl::Init(const WebContents::CreateParams& params) {
                                          std::move(view_),
                                          &render_view_host_delegate_view_));
   }
+  }
   CHECK(render_view_host_delegate_view_);
   CHECK(view_.get());
 
@@ -2040,12 +2047,15 @@ void WebContentsImpl::CreateNewWindow(
       static_cast<SessionStorageNamespaceImpl*>(session_storage_namespace);
   CHECK(session_storage_namespace_impl->IsFromContext(dom_storage_context));
 
+  content::WebContentsView* view = NULL;
+  content::RenderViewHostDelegateView* delegate_view = NULL;
+
   if (delegate_ &&
       !delegate_->ShouldCreateWebContents(
           this, source_site_instance, render_view_route_id, main_frame_route_id,
           main_frame_widget_route_id, params.window_container_type,
           params.opener_url, params.frame_name, params.target_url, partition_id,
-          session_storage_namespace)) {
+          session_storage_namespace, &view, &delegate_view)) {
     // Note: even though we're not creating a WebContents here, it could have
     // been created by the embedder so ensure that the RenderFrameHost is
     // properly initialized.
@@ -2070,6 +2080,8 @@ void WebContentsImpl::CreateNewWindow(
   create_params.opener_render_process_id = render_process_id;
   create_params.opener_render_frame_id = params.opener_render_frame_id;
   create_params.opener_suppressed = params.opener_suppressed;
+  create_params.view = view;
+  create_params.delegate_view = delegate_view;
   if (params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB)
     create_params.initially_hidden = true;
   create_params.renderer_initiated_creation =
diff --git content/public/browser/web_contents.cc content/public/browser/web_contents.cc
index fa0afb5..d677b31 100644
--- content/public/browser/web_contents.cc
+++ content/public/browser/web_contents.cc
@@ -29,7 +29,9 @@ WebContents::CreateParams::CreateParams(BrowserContext* context,
       guest_delegate(nullptr),
       context(nullptr),
       renderer_initiated_creation(false),
-      initialize_renderer(false) {
+      initialize_renderer(false),
+      view(nullptr),
+      delegate_view(nullptr) {
 }
 
 WebContents::CreateParams::CreateParams(const CreateParams& other) = default;
diff --git content/public/browser/web_contents.h content/public/browser/web_contents.h
index a5e2535..704c137 100644
--- content/public/browser/web_contents.h
+++ content/public/browser/web_contents.h
@@ -59,9 +59,11 @@ class PageState;
 class RenderFrameHost;
 class RenderProcessHost;
 class RenderViewHost;
+class RenderViewHostDelegateView;
 class RenderWidgetHost;
 class RenderWidgetHostView;
 class WebContentsDelegate;
+class WebContentsView;
 struct CustomContextMenuContext;
 struct DropData;
 struct Manifest;
@@ -162,6 +164,10 @@ class WebContents : public PageNavigator,
     // Note that the pre-created renderer process may not be used if the first
     // navigation requires a dedicated or privileged process, such as a WebUI.
     bool initialize_renderer;
+
+    // Optionally specify the view and delegate view.
+    content::WebContentsView* view;
+    content::RenderViewHostDelegateView* delegate_view;
   };
 
   // Creates a new WebContents.
diff --git content/public/browser/web_contents_delegate.cc content/public/browser/web_contents_delegate.cc
index 01c9c08..704459d 100644
--- content/public/browser/web_contents_delegate.cc
+++ content/public/browser/web_contents_delegate.cc
@@ -146,7 +146,9 @@ bool WebContentsDelegate::ShouldCreateWebContents(
     const std::string& frame_name,
     const GURL& target_url,
     const std::string& partition_id,
-    SessionStorageNamespace* session_storage_namespace) {
+    SessionStorageNamespace* session_storage_namespace,
+    content::WebContentsView** view,
+    content::RenderViewHostDelegateView** delegate_view) {
   return true;
 }
 
diff --git content/public/browser/web_contents_delegate.h content/public/browser/web_contents_delegate.h
index 6456878..21afa0b 100644
--- content/public/browser/web_contents_delegate.h
+++ content/public/browser/web_contents_delegate.h
@@ -42,11 +42,13 @@ class ColorChooser;
 class JavaScriptDialogManager;
 class PageState;
 class RenderFrameHost;
+class RenderViewHostDelegateView;
 class RenderWidgetHost;
 class SessionStorageNamespace;
 class SiteInstance;
 class WebContents;
 class WebContentsImpl;
+class WebContentsView;
 struct ColorSuggestion;
 struct ContextMenuParams;
 struct DropData;
@@ -323,7 +325,9 @@ class CONTENT_EXPORT WebContentsDelegate {
       const std::string& frame_name,
       const GURL& target_url,
       const std::string& partition_id,
-      SessionStorageNamespace* session_storage_namespace);
+      SessionStorageNamespace* session_storage_namespace,
+      content::WebContentsView** view,
+      content::RenderViewHostDelegateView** delegate_view);
 
   // Notifies the delegate about the creation of a new WebContents. This
   // typically happens when popups are created.
diff --git extensions/browser/guest_view/extension_options/extension_options_guest.cc extensions/browser/guest_view/extension_options/extension_options_guest.cc
index 12dd8f3..c358a52 100644
--- extensions/browser/guest_view/extension_options/extension_options_guest.cc
+++ extensions/browser/guest_view/extension_options/extension_options_guest.cc
@@ -203,7 +203,9 @@ bool ExtensionOptionsGuest::ShouldCreateWebContents(
     const std::string& frame_name,
     const GURL& target_url,
     const std::string& partition_id,
-    content::SessionStorageNamespace* session_storage_namespace) {
+    content::SessionStorageNamespace* session_storage_namespace,
+    content::WebContentsView** view,
+    content::RenderViewHostDelegateView** delegate_view) {
   // This method handles opening links from within the guest. Since this guest
   // view is used for displaying embedded extension options, we want any
   // external links to be opened in a new tab, not in a new guest view.
diff --git extensions/browser/guest_view/extension_options/extension_options_guest.h extensions/browser/guest_view/extension_options/extension_options_guest.h
index 5b0505c..63bf100 100644
--- extensions/browser/guest_view/extension_options/extension_options_guest.h
+++ extensions/browser/guest_view/extension_options/extension_options_guest.h
@@ -54,7 +54,9 @@ class ExtensionOptionsGuest
       const std::string& frame_name,
       const GURL& target_url,
       const std::string& partition_id,
-      content::SessionStorageNamespace* session_storage_namespace) final;
+      content::SessionStorageNamespace* session_storage_namespace,
+      content::WebContentsView** view,
+      content::RenderViewHostDelegateView** delegate_view) final;
 
   // content::WebContentsObserver implementation.
   void DidNavigateMainFrame(const content::LoadCommittedDetails& details,
diff --git ui/keyboard/content/keyboard_ui_content.cc ui/keyboard/content/keyboard_ui_content.cc
index 1dba63e..0268ea3 100644
--- ui/keyboard/content/keyboard_ui_content.cc
+++ ui/keyboard/content/keyboard_ui_content.cc
@@ -67,7 +67,9 @@ class KeyboardContentsDelegate : public content::WebContentsDelegate,
       const std::string& frame_name,
       const GURL& target_url,
       const std::string& partition_id,
-      content::SessionStorageNamespace* session_storage_namespace) override {
+      content::SessionStorageNamespace* session_storage_namespace,
+      content::WebContentsView** view,
+      content::RenderViewHostDelegateView** delegate_view) override {
     return false;
   }
 
diff --git ui/views/controls/webview/web_dialog_view.cc ui/views/controls/webview/web_dialog_view.cc
index cd4f8ec..9b9c9a3 100644
--- ui/views/controls/webview/web_dialog_view.cc
+++ ui/views/controls/webview/web_dialog_view.cc
@@ -343,7 +343,9 @@ bool WebDialogView::ShouldCreateWebContents(
     const std::string& frame_name,
     const GURL& target_url,
     const std::string& partition_id,
-    content::SessionStorageNamespace* session_storage_namespace) {
+    content::SessionStorageNamespace* session_storage_namespace,
+    content::WebContentsView** view,
+    content::RenderViewHostDelegateView** delegate_view) {
   if (delegate_)
     return delegate_->HandleShouldCreateWebContents();
   return true;
diff --git ui/views/controls/webview/web_dialog_view.h ui/views/controls/webview/web_dialog_view.h
index c5d6791..bc1eb5d 100644
--- ui/views/controls/webview/web_dialog_view.h
+++ ui/views/controls/webview/web_dialog_view.h
@@ -125,7 +125,9 @@ class WEBVIEW_EXPORT WebDialogView : public views::ClientView,
       const std::string& frame_name,
       const GURL& target_url,
       const std::string& partition_id,
-      content::SessionStorageNamespace* session_storage_namespace) override;
+      content::SessionStorageNamespace* session_storage_namespace,
+      content::WebContentsView** view,
+      content::RenderViewHostDelegateView** delegate_view) override;
 
  private:
   FRIEND_TEST_ALL_PREFIXES(WebDialogBrowserTest, WebContentRendered);
